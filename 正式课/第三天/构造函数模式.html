<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script>
     /*1，构造函数模式（类） 实例 ,构造函数在new的时候回默认创建一个实例对象，并且会返回。
     ,2， 在构造函数运算的时候，如果return一个基本数据类型，不会改变默认的返回值(实例)；
     *3，如果return一个引用数据类型，默认返回实例对象就被改变成为return的返回的（对象）
     *区别：如果当做构造函数运行会默认返回一个实例，如果一个普通函数运行什么也没返回
     *
     *
     *
     * */
   /* function Table(width) {
        //构造函数中的this使我们的当前实例
        this.width = width;
        this.code = function () {
            console.log('桌子也能coding')
        }
        //return 'haha';
        //return {name:'allen'};

    }
    var table1 = new Table;                //没有参数的时候小括号可以不写 Table（）
    var table2 = new Table(100);
    console.log(table2);                   //对象Table{width:100}       //Object {name: "allen"}
    var table2 = new Table(200);
    console.log(table2);                   //对象Table{width:200}      //Object {name: "allen"}*/


    //构造函数中的私有变量跟实例没有关系  可以用hasOwnProperty来检测是否有这个私有属性
    function Fn() {
        var num = 10;
        this.x = 100;                      //this是window 添加了x属性值为100.
        this.getX = function () {
            console.log(this.x);
        }
    }

    var f = new Fn();                       //f = {x:100,getX:function(){console.log(this.x)}}
    console.log(f.num);                     //undefined  是属性不是变量 所以不报错
   // var k = Fn();                           //100
    console.log(f.getX());                  //100（40行）    undefined（46行） ==>执行完结果没有return
    f.getX();                               //100(40行)           方法中的this是f
    var ss = f.getX;
    ss();                                   //undefined  方法中的this是window


</script>
</body>
</html>